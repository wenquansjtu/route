#! /usr/bin/env node
"use strict";
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/* eslint-disable unicorn/no-array-for-each */
var fs = tslib_1.__importStar(require("fs"));
var stream = tslib_1.__importStar(require("stream"));
var Arrow_js_1 = require("./Arrow.js");
var command_line_usage_1 = tslib_1.__importDefault(require("command-line-usage"));
var command_line_args_1 = tslib_1.__importDefault(require("command-line-args"));
var pad_left_1 = tslib_1.__importDefault(require("pad-left"));
// @ts-ignore
var json_bignum_1 = require("json-bignum");
var argv = (0, command_line_args_1.default)(cliOpts(), { partial: true });
var files = argv.help ? [] : tslib_1.__spreadArray(tslib_1.__spreadArray([], tslib_1.__read((argv.file || [])), false), tslib_1.__read((argv._unknown || [])), false).filter(Boolean);
var state = tslib_1.__assign(tslib_1.__assign({}, argv), { closed: false, maxColWidths: [10] });
(function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var sources, reader, hasReaders, sources_1, sources_1_1, source, _a, _b, _c, batches, toString_1, e_1_1, e_2_1;
    var e_2, _d;
    var _e, e_1, _f, _g;
    return tslib_1.__generator(this, function (_h) {
        switch (_h.label) {
            case 0:
                sources = argv.help ? [] : tslib_1.__spreadArray(tslib_1.__spreadArray([], tslib_1.__read(files.map(function (file) { return function () { return fs.createReadStream(file); }; })), false), tslib_1.__read((process.stdin.isTTY ? [] : [function () { return process.stdin; }])), false).filter(Boolean);
                hasReaders = false;
                _h.label = 1;
            case 1:
                _h.trys.push([1, 18, 19, 20]);
                sources_1 = tslib_1.__values(sources), sources_1_1 = sources_1.next();
                _h.label = 2;
            case 2:
                if (!!sources_1_1.done) return [3 /*break*/, 17];
                source = sources_1_1.value;
                if (state.closed) {
                    return [3 /*break*/, 17];
                }
                _h.label = 3;
            case 3:
                _h.trys.push([3, 9, 10, 15]);
                _a = true, _b = (e_1 = void 0, tslib_1.__asyncValues(recordBatchReaders(source)));
                _h.label = 4;
            case 4: return [4 /*yield*/, _b.next()];
            case 5:
                if (!(_c = _h.sent(), _e = _c.done, !_e)) return [3 /*break*/, 8];
                _g = _c.value;
                _a = false;
                reader = _g;
                hasReaders = true;
                batches = stream.Readable.from(reader);
                toString_1 = batchesToString(state, reader.schema);
                return [4 /*yield*/, pipeTo(batches.pipe(toString_1), process.stdout, { end: false }).catch(function () { return state.closed = true; })];
            case 6:
                _h.sent(); // Handle EPIPE errors
                _h.label = 7;
            case 7:
                _a = true;
                return [3 /*break*/, 4];
            case 8: return [3 /*break*/, 15];
            case 9:
                e_1_1 = _h.sent();
                e_1 = { error: e_1_1 };
                return [3 /*break*/, 15];
            case 10:
                _h.trys.push([10, , 13, 14]);
                if (!(!_a && !_e && (_f = _b.return))) return [3 /*break*/, 12];
                return [4 /*yield*/, _f.call(_b)];
            case 11:
                _h.sent();
                _h.label = 12;
            case 12: return [3 /*break*/, 14];
            case 13:
                if (e_1) throw e_1.error;
                return [7 /*endfinally*/];
            case 14: return [7 /*endfinally*/];
            case 15:
                if (state.closed) {
                    return [3 /*break*/, 17];
                }
                _h.label = 16;
            case 16:
                sources_1_1 = sources_1.next();
                return [3 /*break*/, 2];
            case 17: return [3 /*break*/, 20];
            case 18:
                e_2_1 = _h.sent();
                e_2 = { error: e_2_1 };
                return [3 /*break*/, 20];
            case 19:
                try {
                    if (sources_1_1 && !sources_1_1.done && (_d = sources_1.return)) _d.call(sources_1);
                }
                finally { if (e_2) throw e_2.error; }
                return [7 /*endfinally*/];
            case 20: return [2 /*return*/, hasReaders ? 0 : print_usage()];
        }
    });
}); })()
    .then(function (x) { return +x || 0; }, function (err) {
    if (err) {
        console.error("".concat((err === null || err === void 0 ? void 0 : err.stack) || err));
    }
    return process.exitCode || 1;
}).then(function (code) { return process.exit(code); });
function pipeTo(source, sink, opts) {
    return new Promise(function (resolve, reject) {
        source.on('end', onEnd).pipe(sink, opts).on('error', onErr);
        function onEnd() { done(undefined, resolve); }
        function onErr(err) { done(err, reject); }
        function done(e, cb) {
            source.removeListener('end', onEnd);
            sink.removeListener('error', onErr);
            cb(e);
        }
    });
}
function recordBatchReaders(createSourceStream) {
    return tslib_1.__asyncGenerator(this, arguments, function recordBatchReaders_1() {
        var json, stream, source, reader, readers, _a, _b, _c, _d, e_3_1, _e, _f, _g, _h, _j, _k, _l, _m, e_4_1, _o;
        var _p, e_3, _q, _r, _s, e_4, _t, _u;
        return tslib_1.__generator(this, function (_v) {
            switch (_v.label) {
                case 0:
                    json = new Arrow_js_1.AsyncByteQueue();
                    stream = new Arrow_js_1.AsyncByteQueue();
                    source = createSourceStream();
                    reader = null;
                    readers = null;
                    // tee the input source, just in case it's JSON
                    source.on('end', function () { return [stream, json].forEach(function (y) { return y.close(); }); })
                        .on('data', function (x) { return [stream, json].forEach(function (y) { return y.write(x); }); })
                        .on('error', function (e) { return [stream, json].forEach(function (y) { return y.abort(e); }); });
                    _v.label = 1;
                case 1:
                    _v.trys.push([1, 19, , 20]);
                    _v.label = 2;
                case 2:
                    _v.trys.push([2, 10, 11, 16]);
                    _a = true, _b = tslib_1.__asyncValues(Arrow_js_1.RecordBatchReader.readAll(stream));
                    _v.label = 3;
                case 3: return [4 /*yield*/, tslib_1.__await(_b.next())];
                case 4:
                    if (!(_c = _v.sent(), _p = _c.done, !_p)) return [3 /*break*/, 9];
                    _r = _c.value;
                    _a = false;
                    reader = _r;
                    _d = reader;
                    if (!_d) return [3 /*break*/, 7];
                    return [4 /*yield*/, tslib_1.__await(reader)];
                case 5: return [4 /*yield*/, _v.sent()];
                case 6:
                    _d = (_v.sent());
                    _v.label = 7;
                case 7:
                    _d;
                    _v.label = 8;
                case 8:
                    _a = true;
                    return [3 /*break*/, 3];
                case 9: return [3 /*break*/, 16];
                case 10:
                    e_3_1 = _v.sent();
                    e_3 = { error: e_3_1 };
                    return [3 /*break*/, 16];
                case 11:
                    _v.trys.push([11, , 14, 15]);
                    if (!(!_a && !_p && (_q = _b.return))) return [3 /*break*/, 13];
                    return [4 /*yield*/, tslib_1.__await(_q.call(_b))];
                case 12:
                    _v.sent();
                    _v.label = 13;
                case 13: return [3 /*break*/, 15];
                case 14:
                    if (e_3) throw e_3.error;
                    return [7 /*endfinally*/];
                case 15: return [7 /*endfinally*/];
                case 16:
                    if (!reader) return [3 /*break*/, 18];
                    return [4 /*yield*/, tslib_1.__await(void 0)];
                case 17: return [2 /*return*/, _v.sent()];
                case 18: return [3 /*break*/, 20];
                case 19:
                    _e = _v.sent();
                    readers = null;
                    return [3 /*break*/, 20];
                case 20:
                    if (!!readers) return [3 /*break*/, 40];
                    return [4 /*yield*/, tslib_1.__await(json.closed)];
                case 21:
                    _v.sent();
                    if (source instanceof fs.ReadStream) {
                        source.close();
                    }
                    _v.label = 22;
                case 22:
                    _v.trys.push([22, 39, , 40]);
                    _v.label = 23;
                case 23:
                    _v.trys.push([23, 32, 33, 38]);
                    _f = true;
                    _k = (_j = Arrow_js_1.RecordBatchReader).readAll;
                    _l = json_bignum_1.parse;
                    return [4 /*yield*/, tslib_1.__await(json.toString())];
                case 24:
                    _g = tslib_1.__asyncValues.apply(void 0, [_k.apply(_j, [_l.apply(void 0, [_v.sent()])])]);
                    _v.label = 25;
                case 25: return [4 /*yield*/, tslib_1.__await(_g.next())];
                case 26:
                    if (!(_h = _v.sent(), _s = _h.done, !_s)) return [3 /*break*/, 31];
                    _u = _h.value;
                    _f = false;
                    reader = _u;
                    _m = reader;
                    if (!_m) return [3 /*break*/, 29];
                    return [4 /*yield*/, tslib_1.__await(reader)];
                case 27: return [4 /*yield*/, _v.sent()];
                case 28:
                    _m = (_v.sent());
                    _v.label = 29;
                case 29:
                    _m;
                    _v.label = 30;
                case 30:
                    _f = true;
                    return [3 /*break*/, 25];
                case 31: return [3 /*break*/, 38];
                case 32:
                    e_4_1 = _v.sent();
                    e_4 = { error: e_4_1 };
                    return [3 /*break*/, 38];
                case 33:
                    _v.trys.push([33, , 36, 37]);
                    if (!(!_f && !_s && (_t = _g.return))) return [3 /*break*/, 35];
                    return [4 /*yield*/, tslib_1.__await(_t.call(_g))];
                case 34:
                    _v.sent();
                    _v.label = 35;
                case 35: return [3 /*break*/, 37];
                case 36:
                    if (e_4) throw e_4.error;
                    return [7 /*endfinally*/];
                case 37: return [7 /*endfinally*/];
                case 38: return [3 /*break*/, 40];
                case 39:
                    _o = _v.sent();
                    readers = null;
                    return [3 /*break*/, 40];
                case 40: return [2 /*return*/];
            }
        });
    });
}
function batchesToString(state, schema) {
    var rowId = 0;
    var batchId = -1;
    var maxColWidths = [10];
    var hr = state.hr, sep = state.sep, metadata = state.metadata;
    var header = tslib_1.__spreadArray(['row_id'], tslib_1.__read(schema.fields.map(function (f) { return "".concat(f); })), false).map(function (val) { return Arrow_js_1.util.valueToString(val); });
    state.maxColWidths = header.map(function (x, i) { return Math.max(maxColWidths[i] || 0, x.length); });
    return new stream.Transform({
        encoding: 'utf8',
        writableObjectMode: true,
        readableObjectMode: false,
        final: function (cb) {
            // if there were no batches, then print the Schema, and metadata
            if (batchId === -1) {
                hr && this.push("".concat(horizontalRule(state.maxColWidths, hr, sep), "\n\n"));
                this.push("".concat(formatRow(header, maxColWidths, sep), "\n"));
                if (metadata && schema.metadata.size > 0) {
                    this.push("metadata:\n".concat(formatMetadata(schema.metadata), "\n"));
                }
            }
            hr && this.push("".concat(horizontalRule(state.maxColWidths, hr, sep), "\n\n"));
            cb();
        },
        transform: function (batch, _enc, cb) {
            var e_5, _a;
            var _b;
            batch = !((_b = state.schema) === null || _b === void 0 ? void 0 : _b.length) ? batch : batch.select(state.schema);
            if (state.closed) {
                return cb(undefined, null);
            }
            // Pass one to convert to strings and count max column widths
            state.maxColWidths = measureColumnWidths(rowId, batch, header.map(function (x, i) { return Math.max(maxColWidths[i] || 0, x.length); }));
            // If this is the first batch in a stream, print a top horizontal rule, schema metadata, and
            if (++batchId === 0) {
                hr && this.push("".concat(horizontalRule(state.maxColWidths, hr, sep), "\n"));
                if (metadata && batch.schema.metadata.size > 0) {
                    this.push("metadata:\n".concat(formatMetadata(batch.schema.metadata), "\n"));
                    hr && this.push("".concat(horizontalRule(state.maxColWidths, hr, sep), "\n"));
                }
                if (batch.numRows <= 0 || batch.numCols <= 0) {
                    this.push("".concat(formatRow(header, maxColWidths = state.maxColWidths, sep), "\n"));
                }
            }
            if (batch.numRows > 0 && batch.numCols > 0) {
                // If any of the column widths changed, print the header again
                if (rowId % 350 !== 0 && JSON.stringify(state.maxColWidths) !== JSON.stringify(maxColWidths)) {
                    this.push("".concat(formatRow(header, state.maxColWidths, sep), "\n"));
                }
                maxColWidths = state.maxColWidths;
                try {
                    for (var batch_1 = tslib_1.__values(batch), batch_1_1 = batch_1.next(); !batch_1_1.done; batch_1_1 = batch_1.next()) {
                        var row = batch_1_1.value;
                        if (state.closed) {
                            break;
                        }
                        else if (!row) {
                            continue;
                        }
                        if (rowId % 350 === 0) {
                            this.push("".concat(formatRow(header, maxColWidths, sep), "\n"));
                        }
                        this.push("".concat(formatRow(tslib_1.__spreadArray([rowId++], tslib_1.__read(row.toArray()), false).map(function (v) { return Arrow_js_1.util.valueToString(v); }), maxColWidths, sep), "\n"));
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (batch_1_1 && !batch_1_1.done && (_a = batch_1.return)) _a.call(batch_1);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
            }
            cb();
        }
    });
}
function horizontalRule(maxColWidths, hr, sep) {
    if (hr === void 0) { hr = ''; }
    if (sep === void 0) { sep = ' | '; }
    return " ".concat((0, pad_left_1.default)('', maxColWidths.reduce(function (x, y) { return x + y; }, -2 + maxColWidths.length * sep.length), hr));
}
function formatRow(row, maxColWidths, sep) {
    if (row === void 0) { row = []; }
    if (maxColWidths === void 0) { maxColWidths = []; }
    if (sep === void 0) { sep = ' | '; }
    return "".concat(row.map(function (x, j) { return (0, pad_left_1.default)(x, maxColWidths[j]); }).join(sep));
}
function formatMetadataValue(value) {
    if (value === void 0) { value = ''; }
    var parsed = value;
    try {
        parsed = JSON.stringify(JSON.parse(value), null, 2);
    }
    catch (_a) {
        parsed = value;
    }
    return Arrow_js_1.util.valueToString(parsed).split('\n').join('\n  ');
}
function formatMetadata(metadata) {
    return tslib_1.__spreadArray([], tslib_1.__read(metadata), false).map(function (_a) {
        var _b = tslib_1.__read(_a, 2), key = _b[0], val = _b[1];
        return "  ".concat(key, ": ").concat(formatMetadataValue(val));
    }).join(',  \n');
}
function measureColumnWidths(rowId, batch, maxColWidths) {
    var e_6, _a, e_7, _b;
    if (maxColWidths === void 0) { maxColWidths = []; }
    var val, j = 0;
    try {
        for (var batch_2 = tslib_1.__values(batch), batch_2_1 = batch_2.next(); !batch_2_1.done; batch_2_1 = batch_2.next()) {
            var row = batch_2_1.value;
            if (!row) {
                continue;
            }
            maxColWidths[j = 0] = Math.max(maxColWidths[0] || 0, ("".concat(rowId++)).length);
            try {
                for (var row_1 = (e_7 = void 0, tslib_1.__values(row)), row_1_1 = row_1.next(); !row_1_1.done; row_1_1 = row_1.next()) {
                    val = row_1_1.value;
                    if (val && typedArrayElementWidths.has(val.constructor) && (typeof val[Symbol.toPrimitive] !== 'function')) {
                        // If we're printing a column of TypedArrays, ensure the column is wide enough to accommodate
                        // the widest possible element for a given byte size, since JS omits leading zeroes. For example:
                        // 1 |  [1137743649,2170567488,244696391,2122556476]
                        // 2 |                                          null
                        // 3 |   [637174007,2142281880,961736230,2912449282]
                        // 4 |    [1035112265,21832886,412842672,2207710517]
                        // 5 |                                          null
                        // 6 |                                          null
                        // 7 |     [2755142991,4192423256,2994359,467878370]
                        var elementWidth = typedArrayElementWidths.get(val.constructor);
                        maxColWidths[j + 1] = Math.max(maxColWidths[j + 1] || 0, 2 + // brackets on each end
                            (val.length - 1) + // commas between elements
                            (val.length * elementWidth) // width of stringified 2^N-1
                        );
                    }
                    else {
                        maxColWidths[j + 1] = Math.max(maxColWidths[j + 1] || 0, Arrow_js_1.util.valueToString(val).length);
                    }
                    ++j;
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (row_1_1 && !row_1_1.done && (_b = row_1.return)) _b.call(row_1);
                }
                finally { if (e_7) throw e_7.error; }
            }
        }
    }
    catch (e_6_1) { e_6 = { error: e_6_1 }; }
    finally {
        try {
            if (batch_2_1 && !batch_2_1.done && (_a = batch_2.return)) _a.call(batch_2);
        }
        finally { if (e_6) throw e_6.error; }
    }
    return maxColWidths;
}
// Measure the stringified representation of 2^N-1 for each TypedArray variant
var typedArrayElementWidths = (function () {
    var maxElementWidth = function (ArrayType) {
        var octets = Array.from({ length: ArrayType.BYTES_PER_ELEMENT - 1 }, function (_) { return 255; });
        return "".concat(new ArrayType(new Uint8Array(tslib_1.__spreadArray(tslib_1.__spreadArray([], tslib_1.__read(octets), false), [254], false)).buffer)[0]).length;
    };
    return new Map([
        [Int8Array, maxElementWidth(Int8Array)],
        [Int16Array, maxElementWidth(Int16Array)],
        [Int32Array, maxElementWidth(Int32Array)],
        [Uint8Array, maxElementWidth(Uint8Array)],
        [Uint16Array, maxElementWidth(Uint16Array)],
        [Uint32Array, maxElementWidth(Uint32Array)],
        [Float32Array, maxElementWidth(Float32Array)],
        [Float64Array, maxElementWidth(Float64Array)],
        [Uint8ClampedArray, maxElementWidth(Uint8ClampedArray)]
    ]);
})();
function cliOpts() {
    return [
        {
            type: String,
            name: 'schema', alias: 's',
            optional: true, multiple: true,
            typeLabel: '{underline columns}',
            description: 'A space-delimited list of column names'
        },
        {
            type: String,
            name: 'file', alias: 'f',
            optional: true, multiple: true,
            description: 'The Arrow file to read'
        },
        {
            type: String,
            name: 'sep', optional: true, default: ' | ',
            description: 'The column separator character (default: " | ")'
        },
        {
            type: String,
            name: 'hr', optional: true, default: '',
            description: 'The horizontal border character (default: "")'
        },
        {
            type: Boolean,
            name: 'metadata', alias: 'm',
            optional: true, default: false,
            description: 'Flag to print Schema metadata (default: false)'
        },
        {
            type: Boolean,
            name: 'help', optional: true, default: false,
            description: 'Print this usage guide.'
        }
    ];
}
function print_usage() {
    console.log((0, command_line_usage_1.default)([
        {
            header: 'arrow2csv',
            content: 'Print a CSV from an Arrow file'
        },
        {
            header: 'Synopsis',
            content: [
                '$ arrow2csv {underline file.arrow} [{bold --schema} column_name ...]',
                '$ arrow2csv [{bold --schema} column_name ...] [{bold --file} {underline file.arrow}]',
                '$ arrow2csv {bold -s} column_1 {bold -s} column_2 [{bold -f} {underline file.arrow}]',
                '$ arrow2csv [{bold --help}]'
            ]
        },
        {
            header: 'Options',
            optionList: cliOpts()
        },
        {
            header: 'Example',
            content: [
                '$ arrow2csv --schema foo baz --sep " , " -f simple.arrow',
                '>   "row_id", "foo: Int32", "baz: Utf8"',
                '>          0,            1,        "aa"',
                '>          1,         null,        null',
                '>          2,            3,        null',
                '>          3,            4,       "bbb"',
                '>          4,            5,      "cccc"',
            ]
        }
    ]));
    return 1;
}
